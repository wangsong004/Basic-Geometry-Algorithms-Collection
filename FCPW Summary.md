# 15-400项目报告

## 1. 简介

### 1.1 问题描述

- 最近点查询(Closest Point Queries, CPQs)解决了一个简单的问题:相对于输入位置,在某个表面上最近的点在哪里? 当处理三角形网格时,这很容易通过计算每个三角形的最小距离来完成。然而,我们可以使用各种加速结构来计算最近点,速度远远快于线性增长。CPQs是几何计算中的基础工具,许多相关算法都依赖于它们,包括但不限于碰撞检测和模拟、模拟距离相关的力、计算有符号距离场、球体追踪隐式曲面以及蒙特卡洛几何处理。所有这些算法都使用CPQs作为基本原语,因此它们的性能很大程度上取决于计算数百万或数十亿个CPQs的效率。如果我们能够提高CPQs的实现速度,许多其他几何算法的性能都将受益。

### 1.2 方法

- 我们的目标是确定什么样的算法和系统级权衡对于有效计算最近点查询是可取的。我们建立在之前高性能光线追踪工作的基础上,探索哪些对光线交叉有用的优化也适用于最近点。为了确定最佳选择,我们在CPU和GPU上实现了各种类型的包围盒层次结构(Bounding Volume Hierarchies, BVHs)。我们已经产生了一个矢量化、并行的CPU最近点库,以及一个并行的GPU计算实现,并在这里报告了我们的基准测试结果。

### 1.3 相关工作

- 之前很多关于高性能光线追踪(一个非常相似的问题)的工作都集中在改善BVH的构建质量和查询性能。BVH是一种树状结构,其中每个子树表示一组基元图形,并包含一个包围这些图形的包围体。BVH可用于加速找到光线交点或最近点,因为在这两种情况下,我们都可以定义一个递归遍历规则:只有当它可以改善目前看到的最佳结果时,才遍历内部节点的子节点。

- 然而,有许多不同的方式来构建和查询BVH。为了获得针对特定问题的最佳加速结构,我们可以选择许多参数,如分支因子、叶子大小、节点分割启发式(如表面积、体积、重叠等)以及节点包围体(如轴对齐盒、定向盒等)。此外,还有几种利用并行性的方法。一旦构建了合适的BVH,最简单的策略就是并行化许多独立的查询。但是,应用SIMD(单指令多数据)并行性就不那么简单了:我们可以矢量化独立的查询,但之前的光线追踪工作表明,在BVH遍历过程中执行发散可能成为一个重要问题。因此,也可以对BVH本身进行矢量化。

### 1.4 贡献

- 总的来说,我们发现尽管它们有相似之处,但计算最近点是一个比光线交点要复杂得多的计算任务。CPQs通常必须遍历BVH中的大部分节点,特别是在中心线附近。查询矢量化策略通常会遇到发散问题,即使对于连贯的输入也是如此。

- 在CPU方面,我们的工作确认了大多数之前用于高性能光线追踪的技术对于CPQs也同样适用。例如,我们看到使用矢量化树带来了显著的性能提升。然而,与光线不同的是,我们发现使用更复杂的包围体,如定向包围盒,通常会由于更好的基元剔除而提高性能。

- 在GPU上,我们发现没有基于BVH的方法能够比CPU实现快几个数量级,因为它们都难以应对执行发散。这种发散对性能的危害尤其大,因为每个查询向量通道都必须检查许多不同的基元。然而,我们注意到一些GPU方法是可行的,重点是使用无栈BVH遍历和带有排序优化的宽遍历。

## 2. 方法

### 2.1 CPU

- 我们的CPU实现是一个使用Enoki库进行矢量化的自定义C++代码库。它支持使用各种分割启发式、包围体和SIMD矢量化宽度来构建BVH。

- 在CPU上,查询是通过标准的递归BVH遍历执行的。我们支持基于线程和SIMD的并行性,但采取了不同的方法。基于线程的并行性只是将输入查询划分为块,并调度到线程池中的各个工作线程上。SIMD并行性是通过扩展单个BVH节点来引入的:我们取一个普通的二叉BVH,并将内部节点的子节点折叠到该节点中。这个过程可以重复N次,得到一个分支因子为2^N的BVH。结果BVH节点包含一个SIMD宽度的子包围盒和节点索引集合。此外,叶节点中的连续基元被打包成通道宽度的数据包。

### 2.2 GPU

- 我们的GPU实现也是一个自定义的C++代码库。它使用Vulkan与GPU进行交互,其中各种BVH遍历被实现为计算着色器。BVH构建在CPU上完成,然后被打包到GPU驻留缓冲区并发送到计算着色器。

- 所有BVH遍历都遵循相同的基本公式。BVH被表示为一对连续的GPU缓冲区,一个保存线性化的BVH节点树,另一个保存排序后的基元图形列表。节点数组是通过深度优先遍历排列的,以匹配大多数遍历的空间访问行为。BVH节点包含一个包围其子树中所有基元的体积。内部节点引用两个子节点的索引,叶节点引用基元数组的一个连续区域。

- 我们支持以下遍历策略:

- 显式栈式

- 显式无栈式

- 线程式无栈

- 宽BVH

- 定向包围盒BVH

## 3. 评估

### 3.1 CPU

- 3.1.1 线程/SIMD

	- 我们在一个18核36线程的Intel Core i9-9980XE处理器上运行了CPU基准测试,时钟频率约为3.8GHz。计时结果是处理100万个最近点或1000万个光线交点。并行扩展通常不依赖于输入网格,因为单个BVH是预先计算好的,用于所有查询。

	- 我们的基于线程的并行性没有特殊的性能障碍,因为查询是独立的,不会改变BVH。我们观察到几乎完美的线性扩展,涵盖了所有核心数量。

	- 对于SIMD BVH,我们观察到大约1.8倍的最近点查询加速和1.25倍的光线查询加速,这与之前在高性能光线追踪中的结果一致,并超过了之前针对最近点的结果。

- 3.1.2 包围体

	- 我们实现了使用三种额外类型的节点包围体的二叉BVH:定向包围盒、包围球和球扫矩形。对于最近点查询,使用定向包围盒(OBB)通常会提高性能,因为它们能更好地贴合相关几何体,从而在遍历过程中提高剔除效果。

- 3.1.3 与Embree的比较

	- 我们将我们的扩展结果与Intel的Embree生产BVH库进行了比较。我们的最近点查询性能约为Embree的2倍,这归功于我们对最近点基元计算的矢量化。我们的光线查询性能落后Embree约2倍,可能是由于使用了较不先进的BVH构建算法。

### 3.2 GPU

- 在GPU上,SIMD情况是预先确定的:一组查询必须自动划分为可在独立GPU核心上运行的块。每个块被划分为32宽的SIMD线程束,在单个GPU核心内运行。

- 我们关注于比较各种BVH遍历和构建策略的性能。总的来说,即使对于连贯的输入,执行发散和糟糕的剔除行为也是GPU实现的主要限制因素。即使使用最优的遍历算法,GPU实现也很难超过使用32线程的CPU实现。

- 3.2.1 测试用例

	- 立方体
对于只有很少基元的场景,最有效的策略是简单地将每个查询与每个基元进行测试。

	- 兔子
兔子是一个普通的单网格测试用例,不会显示任何令人惊讶的行为。最近点查询比光线交点慢得多,因为它们必须遍历整个BVH来找到真正最近的基元。

	- Sponza
Sponza是一个分布式几何测试用例,其最近点查询性能明显优于兔子,因为它没有太多棘手的中心线情况。

- 3.2.2 遍历策略

	- 栈式vs无栈式
无栈式遍历通常比栈式遍历表现更好,因为它们能增加线程束占用率并减少寄存器压力。

	- 定向盒vs轴对齐盒
使用定向盒(OBB)的利弊取决于测试用例。对于大多数测试,OBB会降低性能,因为大部分几何体可以很好地适合轴对齐盒。但对于Sponza场景的某些部分(如植被网格),OBB确实能提高性能。

	- 树宽度
宽BVH通常提供温和的性能改善,因为它能减少依赖内存访问的遍历链。但是,扩展树的同时也引入了一些不必要的工作。

	- 宽度排序优化
为宽树提供的遍历顺序优化(首先遍历最近的子节点,或按距离对所有子节点进行排序)大大提高了最近点查询的剔除效果。

- 3.2.3 光线vs最近点

	- 对于光线,无栈式遍历二叉轴对齐BVH是最佳选择,这与之前的高性能GPU光线追踪工作一致。

	- 对于最近点,情况要复杂得多,取决于输入网格的性质。这是因为最近点需要遍历BVH树的大部分内容,因此比光线交点慢10-100倍。

- 3.2.4 输入连贯性

	- 随机化输入查询会导致性能下降30%-300%,因为执行发散增加。然而,这对最近点的影响没有之前观察到的对光线交点的影响大,因为最近点本来就缺乏足够的连贯性。

### 3.3 GPU vs CPU

- 将CPU和GPU实现的最近点查询性能进行比较并不完全公平,因为它们采用的并行策略非常不同,对不同输入的响应也不同。在最佳情况下(智能遍历算法,合适的输入),GPU实现的性能可以超过我们32线程CPU实现的2-10倍。在最坏情况下(糟糕的遍历算法,发散输入),GPU实现的性能可能落后CPU 2-10倍。

## 4. 经验教训

### 从学术角度来看,通过实现各种BVH构建和遍历策略来探索它们,而不仅仅是阅读论文,是很有趣的。同样,在GPU上推理各种性能权衡也是启发性的,尽管我们没有找到一种万能的解决方案。我还学会了如何使用Vulkan及其新的硬件光线追踪API,这对未来的工作很有帮助。总的来说,我学到了做研究作为一个忙碌的本科生是很困难的,保持连接性在独自在家工作时也是一个挑战,我应该更频繁地寻求指导。

## 5. 结论和未来工作

### 在CPU方面,我们的工作确认了大多数针对高性能光线追踪的性能调优技术也适用于最近点查询。在GPU方面,我们发现没有基于BVH的方法能够大幅提高CPU实现的性能,因为它们都难以应对执行发散。然而,我们注意到一些GPU方法是非常可行的,重点是使用无栈BVH遍历和带有排序优化的宽遍历。

### 未来,我们希望将我们的发现发展成一个广泛有用的开源最近点查询库。这将对许多其他投影和应用程序很有用。此外,探索使用

